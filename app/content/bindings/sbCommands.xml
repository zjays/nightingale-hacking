<?xml version="1.0"?>
<!--
/*
 *=BEGIN SONGBIRD GPL
 *
 * This file is part of the Songbird web player.
 *
 * Copyright(c) 2005-2010 POTI, Inc.
 * http://www.songbirdnest.com
 *
 * This file may be licensed under the terms of of the
 * GNU General Public License Version 2 (the ``GPL'').
 *
 * Software distributed under the License is distributed
 * on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY KIND, either
 * express or implied. See the GPL for the specific language
 * governing rights and limitations.
 *
 * You should have received a copy of the GPL along with this
 * program. If not, go to http://www.gnu.org/licenses/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *=END SONGBIRD GPL
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="commands-base">

    <implementation type="application/x-javascript">

      <constructor>
        <![CDATA[
          this._destroyed = false;
          this._deferRefresh = false;
          this._needRefresh = false;
          this._laststateonly = false;
          // Load up the string bundle
          var src = "chrome://songbird/locale/songbird.properties";
          var stringBundleService =
              Components.classes["@mozilla.org/intl/stringbundle;1"]
              .getService(Components.interfaces.nsIStringBundleService);
          this.stringbundle = stringBundleService.createBundle( src );
          this._playlistCommandsListener = null;
          var selfbind = this.getAttribute("bind");
          if (selfbind) {
            var libraryManager =
              Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                        .getService(Components.interfaces.sbILibraryManager);
            var guids = selfbind.split(';');
            var libraryguid = guids[0];
            var playlistguid = guids[1];
            var bindtomedialist = null;
            var library = libraryManager.getLibrary(libraryguid);
            if (library) {
              if (libraryguid == playlistguid) bindtomedialist = library;
              else bindtomedialist = library.getMediaItem(playlistguid);
            }
            if (bindtomedialist) {
              this.bind(bindtomedialist, null, null);
            }
          }
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
        if (this._destroyed) return;
        this.destroy();
        ]]>
      </destructor>

      <method name="destroy">
        <body>
          <![CDATA[
          if (!this._destroyed) {
            this.removeCommands();

            // remove the listeners for this medialist's playlist commands
            var playlistCmdsMgr =
                Components.classes["@songbirdnest.com/Songbird/PlaylistCommandsManager;1"]
                          .getService(Components.interfaces.sbIPlaylistCommandsManager);
            playlistCmdsMgr.removeListenerForMediaList(this.medialist,
                                                       this._playlistCommandsListener);
            this._playlistCommandsListener = null;
            this.emptyCommandsArray();
            this.stringbundle = null;
            this._outerWindow = null;
            this.medialist = null;
            this.playlist = null;
            this.defaultcommands = null;
            this._outerWindow = null;
            try {
              this.destroy2();
            } catch (e) {}
            this._destroyed = true;
          }
        ]]>
        </body>
      </method>

      <property name="commandtype">
        <getter>
          return this.getAttribute("commandtype");
        </getter>
        <setter>
          this.setAttribute("commandtype", val);
        </setter>
      </property>

      <field name="commands">null</field>
      <field name="playlist">null</field>
      <field name="medialist">null</field>
      <field name="hoststring">"generic"</field>

      <field name="_outerWindow">null</field>
      <property name="outerWindow">
        <getter>
          <![CDATA[
            return this._outerWindow;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            return this._outerWindow = val;
          ]]>
        </setter>
      </property>

      <property name="usedefault">
        <getter>
          return (this.getAttribute("usedefault") != "false");
        </getter>
        <setter>
          <![CDATA[
            var old = this.usedefault;
            this.setAttribute("usedefault", val);
            if (this.commands && this.usedefault != old) {
              this.rescanCommands();
            }
          ]]>
        </setter>
      </property>

      <method name="bind">
        <parameter name="medialist"/>
        <parameter name="playlist"/>
        <parameter name="commands"/>
        <body>
        <![CDATA[
          try {
            this.medialist = medialist;

            var outerListGuid = this.medialist.getProperty(SBProperties.outerGUID);
            if (outerListGuid) {
              var library = this.medialist.library;
              var outerList = library.getMediaItem(outerListGuid);
              if (outerList) {
                this.medialist = outerList;
              }
            }

            this.playlist = playlist;
            this.defaultcommands = commands ? commands.duplicate() : null;

            /* Add a listener to the root commands for this medialist so that
             * we can rescan the commands should they change.  For example
             * this causes a rescan when a new command is added for a medialist,
             * displaying it immediately after its addition */
            var playlistCmdsMgr =
                Components.classes["@songbirdnest.com/Songbird/PlaylistCommandsManager;1"]
                          .getService(Components.interfaces.sbIPlaylistCommandsManager);
            var self = this;
            var listener = {
              onCommandAdded: function listener_onCommandAdded(aCommandObject) {
                self.rescanCommands();
              },
              onCommandRemoved: function listener_onCommandRemoved(aCommandObject) {
                self.rescanCommands();
              },
              onCommandChanged: function listener_onCommandChanged(aCommandObject) {
                self.rescanCommands();
              },
              QueryInterface: XPCOMUtils.generateQI
                                        ([Components.interfaces.sbIPlaylistCommandsListener]),
            };

            playlistCmdsMgr.addListenerForMediaList(this.medialist, listener);
            this._playlistCommandsListener = listener;
            this.rescanCommands();
          } catch (e) {
              Components.utils.reportError( "sbCommands.xml - bind - " + e );
          }
        ]]>
        </body>
      </method>

      <method name="emptyCommandsArray">
        <body>
          <![CDATA[
            // the creator of the commands should call their shutdown methods
            // so we only need to make a new array for this
            this.commands = new Array();
          ]]>
        </body>
      </method>
      <method name="rescanCommands">
        <body>
          <![CDATA[
            if (this.medialist) {
              //Components.utils.reportError("rescanCommands for " + this.hoststring + " - " + this.medialist.name);
              this.emptyCommandsArray();
              var source =
                  Components.classes["@songbirdnest.com/Songbird/PlaylistCommandsManager;1"]
                                    .getService(Components.interfaces.sbIPlaylistCommandsManager);
              var rootCommand;
              switch (this.commandtype) {
                case "medialist":
                  rootCommand = source.getPlaylistCommandsMediaList
                                       (this.medialist.guid, this.medialist.type);
                  break;
                // default case
                case "mediaitem":
                case "":
                default:
                  rootCommand = source.getPlaylistCommandsMediaItem
                                       (this.medialist.guid, this.medialist.type);
                  break;
              }
              if ( rootCommand )
              {
                var cmds = rootCommand.getChildrenCommandObjects();
                while (cmds.hasMoreElements()) {
                  var obj = cmds.getNext();

                  // make sure obj is a sbIPlaylistCommands and add it to our array
                  if (obj instanceof Components.interfaces.sbIPlaylistCommands) {
                    obj.initCommands(this.hoststring);
                    this.commands.push(obj);
                  }
                }
              }

              // Use the defaults only if allowed and if we didnt get anything so far
              if (this.usedefault && !this.commands.length) {
                // add the default (generic) command object if specified
                if (this.defaultcommands) {
                  this.defaultcommands.initCommands(this.hoststring);
                  this.commands.push(this.defaultcommands);
                }
              }
              this.refreshCommands();
            }
          ]]>
        </body>
      </method>

      <method name="setDeferRefresh">
        <body>
          <![CDATA[
            try
            {
              this._deferRefresh = true;
            }
            catch( err )
            {
              Components.utils.reportError( "sbCommands.xml - setDeferRefresh - " + err );
            }
          ]]>
        </body>
      </method>

      <method name="clearDeferRefresh">
        <body>
          <![CDATA[
            try
            {
              this._deferRefresh = false;
              if (this._needRefresh)
                this.refreshCommands(false);
            }
            catch( err )
            {
              Components.utils.reportError( "sbCommands.xml - clearDeferRefresh - " + err );
            }
          ]]>
        </body>
      </method>

      <method name="refreshCommands">
        <parameter name="stateonly"/>
        <body>
          <![CDATA[
            var skip = false;

            // Sometimes we get here before the tree is properly built.  That's bad.
            // Also skip if the playlist is not visible, or if our context has not
            // yet been given a playlist at all.

            try
            {
            if (this.playlist) {
              // safety test, is the playlist ready ?
              var err = false;
              try {
                var a = this.playlist.tree.currentIndex;
              } catch (e) {
                skip=true;
              }
            }
            if (!this.medialist) skip = true;
            if (this.playlist) {
              if (this.playlist.getAttribute("hidden") == "true" ||
                  !this.playlist.mediaListView ||
                  !this.playlist.mediaListView.treeView) {
                skip = true;
              }
            }
            if (skip)
            {
              // So if we're supposed to build the items here, remember that for next time.
              if (!stateonly)
                this._laststateonly = false;
              return;
            }
            // And build them the next time it's time to refresh (this function gets called alot)
            if (!this._laststateonly)
            {
              stateonly = false;
              this._laststateonly = true;
            }

            // Convert null to bool.
            if (!stateonly)
              stateonly = false;

            // If our internal objects are out of sync, rebuild.
            var forcerebuild = false;
            try {
              forcerebuild = this.shouldForceRebuild();
            } catch (e) { }
            if (forcerebuild)
              stateonly = false;

            // If deferring refresh, skip it
            if ( this._deferRefresh )
            {
              // make a note that we need to refresh when the popup goes away
              this._needRefresh = true;
              // So if we're supposed to build the items here, remember that and quit.
              if (!stateonly)
                this._laststateonly = false;
              return;
            }
            this._needRefresh = false;

            // tell the commands about their context
            if (!stateonly && this.commands) {
              // Once we get here, tell the commands who we are.
              var wnd = this.outerWindow;
              if (!wnd) wnd = window;
              var context = {
                medialist: this.medialist,
                playlist: this.playlist,
                window: wnd,
                commands: null,
                QueryInterface: function(iid) {
                  if (iid.equals(Components.interfaces.sbIPlaylistCommandsContext) ||
                      iid.equals(Components.interfaces.nsISupports))
                    return this;
                  throw Components.results.NS_ERROR_NO_INTERFACE;
                }
              };
              for (var i in this.commands) {
                context.commands = this.commands[i];
                this.commands[i].setContext( context );
              }
            }

            this.doRefreshCommands(stateonly);
          }
          catch( err )
          {
            Components.utils.reportError( "sbCommands.xml - refreshCommands - " + this.hoststring + " - " + err );
          }
          ]]>
        </body>
      </method>

      <method name="removeCommands">
        <body>
          <![CDATA[
          try {
            this.doRemoveCommands();
          } catch (e) {
            Components.utils.reportError( "sbCommands.xml - doRemoveCommands not implemented ? - " + e );
          }
        ]]>
        </body>
      </method>

      <method name="hasCommands">
        <body>
          <![CDATA[
            if (!this.commands) return false;
            for (var i in this.commands) {
              if (this.commands[i].getNumCommands("", this.hoststring) > 0) return true;
            }
            return false;
          ]]>
        </body>
      </method>

      <method name="translateEntity">
        <parameter name="str"/>
        <body>
          <![CDATA[
            if ( str && str.length > 0 )
            {
              if ( str[ 0 ] == "&" )
              {
                try
                {
                  str = this.stringbundle.GetStringFromName( str.substr( 1, str.length ) );
                }
                catch( err )
                {
                  dump("error playlist.xml translateEntity() - getStringFromName for '" + str + "': " + err + "\n");
                }
              }
            }
            return str;
          ]]>
        </body>
      </method>

#ifdef METRICS_ENABLED
      <method name="reportMetrics">
        <parameter name="cmdid"/>
        <body>
          <![CDATA[
            try {
              var metricscategory = this.getAttribute("metricscategory");
              if (!metricscategory) return;
              var library = this.medialist ? this.medialist.library : null;
              var metricstype = library ? library.getProperty("http://songbirdnest.com/data/1.0#customType") : null;
              if (!metricstype) return;
              var p = cmdid.indexOf(":");
              if (p != -1) cmdid = cmdid.slice(0, p);
              p = cmdid.indexOf(";");
              if (p != -1) cmdid = cmdid.slice(0, p);
              p = cmdid.indexOf(",");
              if (p != -1) cmdid = cmdid.slice(0, p);
              metrics_inc(metricscategory, metricstype, cmdid);
            } catch (e) {
              // don't make broken metrics break anything else
            }
          ]]>
        </body>
      </method>
#endif

    </implementation>

  </binding>




  <!-- COMMANDS TOOLBAR -->




  <binding id="commands-toolbar" extends="chrome://songbird/content/bindings/sbCommands.xml#commands-base">

    <content>
      <xul:hbox id="sb-commands-toolbar-bkg" class="sb-commands-toolbar-bkg" sbid="background" flex="1">
        <xul:hbox id="sb-commands-toolbar" class="sb-commands-toolbar" sbid="parent" flex="1" oncommand="onToolbarCommand( event )">
        </xul:hbox>
      </xul:hbox>
    </content>

    <implementation type="application/x-javascript">

    <field name="parent">document.getAnonymousElementByAttribute(this, 'sbid', 'parent');</field>
    <field name="toolbarbuttons">new Array();</field>
    <field name="hoststring">"toolbar"</field>

    <method name="shouldForceRebuild">
      <body>
        // If our internal objects are out of sync, rebuild.
        return (this.toolbarbuttons.length == 0);
      </body>
    </method>

    <method name="doRefreshCommands">
      <parameter name="stateonly"/>
      <body>
        <![CDATA[
        try
        {
          if (!stateonly) {
            this.hidden = true;
            this.removeCommands();
          }

          if ( this.commands )
          {
            for (var i in this.commands) {
              this.refreshCommandItems(this.commands[i], stateonly, null, this.parent, null, 0, false);
            }
            if (this.toolbarbuttons.length) {
              // If we have items, show the toolbar
              this.hidden = false;
            }
          }
        }
        catch( err )
        {
          Components.utils.reportError( "sbCommands.xml - toolbar - doRefreshCommands - " + err );
        }
        ]]>
      </body>
    </method>


    <method name="refreshCommandItems">
      <parameter name="cmdobject"/>
      <parameter name="stateonly"/>
      <parameter name="menu"/>
      <parameter name="parentnode"/>
      <parameter name="before"/>
      <parameter name="depth"/>
      <parameter name="radioitems"/>
      <body>
        <![CDATA[
          var toolbarbutton;
          try {
            if (!cmdobject.getVisible(this.hoststring)) return;
            // And make all the new stuff
            var num = cmdobject.getNumCommands(menu, this.hoststring);
            if (stateonly) num = this.toolbarbuttons.length;
            for ( var i = 0; i < num; i++ )
            {
              // skip ?
              if (!stateonly && !cmdobject.getCommandVisible( menu, i, this.hoststring )) {
                //Components.utils.reportError("toolbar - item " + i + " not visible: " + cmdobject.getCommandId( menu, i, this.hoststring ));
                continue;
              }

              var obj_type;
              toolbarbutton = null;
              if (!stateonly)
              {
                if (radioitems) obj_type = "choiceitem";
                else obj_type = cmdobject.getCommandType( menu, i, this.hoststring );

                // What id?
                var obj_id = cmdobject.getCommandId( menu, i, this.hoststring );

                var toolbarbutton_type;
                var toolbarbutton_typeattr = null;
                if (radioitems) toolbarbutton_typeattr = "checkbox";
                var custom = false;

                var subobject = cmdobject.getCommandSubObject( menu, i, this.hoststring );
                if (subobject) {
                  this.refreshCommandItems(subobject, stateonly, menu, parentnode, before, depth, false);
                  continue;
                }

                if (menu && menu != "") {
                  switch (obj_type) {
                    case "custom":
                    case "value":
                      // ignore this item
                      toolbarbutton_type = null;
                      break;
                    case "separator":
                      toolbarbutton_type = "menuseparator";
                      break;
                    case "submenu":
                    case "choice":
                      if (depth == 0) toolbarbutton_type = "menupopup";
                      else toolbarbutton_type = "menu";
                      break;
                    case "flag":
                    case "choiceitem":
                      toolbarbutton_typeattr = "checkbox";
                      // Fallthru
                    case "action":
                    default:
                      toolbarbutton_type = "menuitem";
                      break;
                  }
                } else {
                  switch (obj_type) {
                    case "custom":
                      custom = true;
                      break;
                    case "separator":
                      toolbarbutton_type = "spacer";
                      break;
                    case "choice":
                      toolbarbutton_type = "menulist";
                      break;
                    case "submenu":
                      toolbarbutton_type = "toolbarbutton";
                      toolbarbutton_typeattr = "menu";
                      break;
                    case "value":
                      toolbarbutton_type = "textbox";
                      break;
                    case "flag":
                    case "choiceitem":
                      toolbarbutton_typeattr = "checkbox";
                      // Fallthru
                    case "action":
                    default:
                      toolbarbutton_type = "toolbarbutton";
                      break;
                  }
                }

                if (!toolbarbutton_type && !custom) continue;

                // Create a toolbarbutton
                if (custom) {
                  toolbarbutton = cmdobject.instantiateCustomCommand(menu, i, this.hoststring, obj_id, document);
                } else {
                  toolbarbutton = document.createElement( toolbarbutton_type );
                }
                if (!toolbarbutton) continue;
                var label = toolbarbutton;
                var topelement = toolbarbutton;
                toolbarbutton.setAttribute( "id", obj_id );
                if (toolbarbutton_type == "menuitem") { toolbarbutton.setAttribute( "class", "menuitem-iconic" ); } // Icons are set in the css using the id
                if (toolbarbutton_typeattr) toolbarbutton.setAttribute( "type", toolbarbutton_typeattr );
                if (toolbarbutton_type == "textbox") {
                  var hbox = document.createElement("hbox");
                  var textlabel = document.createElement("label");
                  var separator = document.createElement("spacer");
                  hbox.setAttribute("align", "center");
                  hbox.appendChild(textlabel);
                  hbox.appendChild(separator);
                  hbox.appendChild(toolbarbutton);
                  toolbarbutton.setAttribute("value", "");
                  toolbarbutton.setAttribute( "sbtype", "command-textbox" ); // to find it easily, later
                  topelement = hbox;
                  label = textlabel;
                }

                topelement.setAttribute( "sbtype", "command" ); // to find it easily, later
                if (!custom) {
                  // No label unless you have a label
                  var cmd_text = cmdobject.getCommandText( menu, i, this.hoststring );
                  if ( cmd_text.length > 0 )
                  {
                    cmd_text = this.translateEntity(cmd_text);
                    if (label.tagName == "label") label.setAttribute( "value", cmd_text+":");
                    else if (label.tagName == "menulist") { /*do nothing*/ }
                    else label.setAttribute( "label", cmd_text );
                  }

                  var cmd_flex = false;
                  if (toolbarbutton_type != "menu" && toolbarbutton_type != "menuitem") cmd_flex = cmdobject.getCommandFlex( menu, i, this.hoststring );

                  if ( cmd_flex > 0 )
                  {
                    toolbarbutton.setAttribute( "flex", cmd_flex );
                  }

                  // No tooltip unless you have a tooltip
                  var tooltip_text = cmdobject.getCommandToolTipText( menu, i, this.hoststring );
                  if ( tooltip_text.length > 0 )
                  {
                    tooltip_text = this.translateEntity(tooltip_text);
                    /*
                        This causes the crashy if it's up while updating.  :(

                      toolbarbutton.setAttribute( "tooltiptext", tooltip_text );
                    */
                  }
                }

                toolbarbutton.commandtype = obj_type;
                toolbarbutton.commanddepth = depth;
                toolbarbutton.commandmenu = menu;
                toolbarbutton.commandindex = i;
                toolbarbutton.commandobject = cmdobject;
                toolbarbutton.commandcustom = custom;
              }
              else
              {
                toolbarbutton = this.toolbarbuttons[i];
                obj_type = toolbarbutton.commandtype;
                cmdobject = toolbarbutton.commandobject;
              }

              if ( cmdobject.getCommandEnabled( toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring ) )
              {
                toolbarbutton.removeAttribute( "disabled" );
              }
              else
              {
                toolbarbutton.setAttribute( "disabled", "true" );
              }

              // Add it to the parent
              if (!stateonly)
              {
                this.toolbarbuttons.push( toolbarbutton );
                if (obj_type == "submenu" || obj_type == "choice") {
                  var parent = toolbarbutton;
                  var menupopup = document.createElement("menupopup");
                  menupopup.setAttribute("sbtype", "command");
                  toolbarbutton.appendChild(menupopup);
                  if (!before) parentnode.appendChild(topelement);
                  else parentnode.insertBefore( topelement, before);
                  parent = menupopup;
                  this.refreshCommandItems(cmdobject, stateonly, cmdobject.getCommandId(menu, i, this.hoststring), parent, null, depth+1, (obj_type == "choice"));
                } else {
                  if (!before) parentnode.appendChild(topelement);
                  else parentnode.insertBefore( topelement, before);
                }
              }

              if (toolbarbutton.commandtype == "flag") {
                toolbarbutton.setAttribute("checked", cmdobject.getCommandFlag( toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring ));
              }

              if (toolbarbutton.commandtype == "value") {
                var val = cmdobject.getCommandValue( toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring );
                toolbarbutton.value = val;
              }
              if (toolbarbutton.commandtype == "choiceitem") {
                if (toolbarbutton.commanddepth > 1) {
                  toolbarbutton.setAttribute("checked", cmdobject.getCommandChoiceItem( toolbarbutton.commandmenu, this.hoststring ) == toolbarbutton.id);
                } else {
                  if (cmdobject.getCommandChoiceItem( toolbarbutton.commandmenu, this.hoststring ) == toolbarbutton.id) {
                    var e = toolbarbutton;
                    while (e && e.tagName != "menulist") { e = e.parentNode; }
                    if (e) e.selectedIndex = toolbarbutton.commandindex;
                  }
                }
              }
              if (toolbarbutton.commandcustom) {
                cmdobject.refreshCustomCommand(toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring, toolbarbutton.id, toolbarbutton);
              }
            }
          } catch (e) {
            var id="";
            if (toolbarbutton) {
              id = "- " + cmdobject.getCommandId(menu, toolbarbutton.commandindex, this.hoststring) + " ";
            }
            Components.utils.reportError("sbCommands.xml - toolbar - refreshCommandItems " + id + e);
          }
        ]]>
      </body>
    </method>

    <method name="doRemoveCommands">
      <body>
        <![CDATA[
          try {
            // Delete the toolbar commands
            var command_nodes = this.parent.getElementsByAttribute( 'sbtype', 'command' );
            // command_nodes is a live array, removing children from parent auto removes items from it
            while ( command_nodes.length > 0 )
            {
              var node = command_nodes.item( 0 );
              this.parent.removeChild(node);
            }
            this.toolbarbuttons.length = 0; // clear the array??
          } catch (e) {
            Components.utils.reportError("sbCommands.xml - toolbar - " + e);
          }
        ]]>
      </body>
    </method>

    <method name="onToolbarCommand">
      <parameter name="evt"/>
      <body>
        <![CDATA[
        try
        {
          if ( this.commands )
          {
            if (!this.parentNode) return;

            var cmdobject = evt.originalTarget.commandobject;
            if (!cmdobject) return;

#ifdef METRICS_ENABLED
            this.reportMetrics(evt.originalTarget.id);
#endif

            cmdobject.onCommand(evt.originalTarget.commandmenu,
                                evt.originalTarget.commandindex,
                                this.hoststring,
                                evt.originalTarget.id,
                                null);

            var type = evt.originalTarget.commandtype;
            if (type == "flag" || type == "choiceitem") this.refreshCommands(true);
          }
        }
        catch( err )
        {
          Components.utils.reportError( "sbCommands.xml - toolbar - onToolbarCommand - " + err );
        }
      ]]>
      </body>
    </method>

    </implementation>

    <handlers>
      <handler event="keypress">
        <![CDATA[
        try
        {
          var element = event.originalTarget;
          if (event.keyCode == 13 && element.tagName == "html:input") {
            while (1) {
              var sbtype = element.getAttribute("sbtype");
              if (sbtype == "command-textbox") break;
              else if (sbtype && sbtype != "") return;
              element = element.parentNode;
            }

#ifdef METRICS_ENABLED
            this.reportMetrics(element.id);
#endif

            var cmdobject = element.commandobject;
            if (!cmdobject) return;
            cmdobject.onCommand(element.commandmenu,
                                element.commandindex,
                                this.hoststring,
                                element.id,
                                element.value);
          }
        }
        catch( err )
        {
          Components.utils.reportError( err )
        }
        ]]>
      </handler>
    </handlers>

  </binding>




  <!-- COMMANDS POPUP -->




  <binding id="commands-menuitems" extends="chrome://songbird/content/bindings/sbCommands.xml#commands-base">

    <implementation type="application/x-javascript">

    <constructor>
      // hide the binding (this does not hide the items, just the binding)
      this.hidden = true;
    </constructor>

    <field name="menuitems">new Array();</field>
    <field name="hoststring">"menu"</field>

    <method name="destroy2">
      <body>
        this.resetParentPopup();
      </body>
    </method>

    <method name="shouldForceRebuild">
      <body>
        // If our internal objects are out of sync, rebuild.
        return (this.menuitems.length == 0);
      </body>
    </method>

    <method name="getParentPopup">
      <body>
        <![CDATA[
          var e = this;
          while (e && e != document) {
            if (e.tagName == "popup" || e.tagName == "xul:popup" ||
                e.tagName == "menupopup" || e.tagName == "xul:menupopup") return e;
            e = e.parentNode;
          }
          return null;
        ]]>
      </body>
    </method>

    <method name="resetParentPopup">
      <body>
        if (this.parentpopup) {
          if (this.oncommand) {
            this.parentpopup.removeEventListener("command", this.oncommand, false);
            this.oncommand._that = null;
            this.oncommand = null;
          }
          if (this.domnoderemoved) {
            this.removeEventListener("DOMNodeRemoved", this.domnoderemoved, false);
            this.domnoderemoved._that = null;
            this.domnoderemoved = null;
          }
        }
      </body>
    </method>

    <method name="doRefreshCommands">
      <parameter name="stateonly"/>
      <body>
        <![CDATA[
        try
        {
          if (!stateonly) {
            this.removeCommands();
          }

          if ( this.commands )
          {
            var popup = this.getParentPopup();
            if (!this.parentpopup) {
              this.parentpopup = popup;
              this.oncommand = {
                _that: null,
                handleEvent: function( event ) { this._that.onMenuCommand(event); }
              }; this.oncommand._that = this;
              popup.addEventListener("command", this.oncommand, false);
              this.domnoderemoved = {
                _that: null,
                handleEvent: function( event ) { this._that.resetParentPopup(event); }
              }; this.domnoderemoved._that = this;
              this.addEventListener("DOMNodeRemoved", this.domnoderemoved, false);
            }
            var before = this;

            if (popup) {
              for (var i in this.commands) {
                this.refreshCommandItems(this.commands[i], stateonly, null, popup, before, 0, false);
              }
            }
          }
        }
        catch( err )
        {
          Components.utils.reportError( "sbCommands.xml - popup - doRefreshCommands - " + err );
        }
        ]]>
      </body>
    </method>

    <method name="refreshCommandItems">
      <parameter name="cmdobject"/>
      <parameter name="stateonly"/>
      <parameter name="menu"/>
      <parameter name="parentnode"/>
      <parameter name="before"/>
      <parameter name="depth"/>
      <parameter name="radioitems"/>
      <body>
        <![CDATA[
          var menuitem;
          try {
            if (!cmdobject.getVisible(this.hoststring)) return;
            // And make all the new stuff
            var num = cmdobject.getNumCommands(menu, this.hoststring);
            if (stateonly) num = this.menuitems.length;
            for ( var i = 0; i < num; i++ )
            {
              menuitem = null;

              // skip ?
              if (!stateonly && !cmdobject.getCommandVisible( menu, i, this.hoststring )) continue;

              // What type?
              var obj_type;

              if (!stateonly)
              {
                if (radioitems) obj_type = "choiceitem";
                else obj_type = cmdobject.getCommandType( menu, i, this.hoststring );

                // What id?
                var obj_id = cmdobject.getCommandId( menu, i, this.hoststring );

                var subobject = cmdobject.getCommandSubObject( menu, i, this.hoststring );
                if (subobject) {
                  this.refreshCommandItems(subobject, stateonly, menu, parentnode, before, depth, false);
                  continue;
                }

                var menuitem_type;

                switch (obj_type) {
                  case "separator":
                    menuitem_type = "menuseparator";
                    break;
                  case "submenu":
                  case "choice":
                    menuitem_type = "menu";
                    break;
                  case "custom":
                  case "value":
                    menuitem_type = "";
                    break;
                  case "action":
                  case "choiceitem":
                  case "flag":
                  default:
                    menuitem_type = "menuitem";
                    break;
                }

                if (menuitem_type == "") continue;

                // And a menuitem
                menuitem = document.createElement( menuitem_type );
                menuitem.setAttribute( "id", obj_id );
                menuitem.setAttribute( "sbtype", "command" );
                menuitem.setAttribute( "class", "menuitem-iconic" ); // Icons are set in the css using the id
                if (obj_type == "flag" || radioitems) menuitem.setAttribute("type", "checkbox");

                // No label unless you have a label
                var cmd_text = cmdobject.getCommandText( menu, i, this.hoststring );
                if ( cmd_text.length > 0 )
                {
                  cmd_text = this.translateEntity(cmd_text);
                  menuitem.setAttribute( "label", cmd_text );
                }

                // No tooltip unless you have a tooltip
                var tooltip_text = cmdobject.getCommandToolTipText( menu, i, this.hoststring );
                if ( tooltip_text.length > 0 )
                {
                  tooltip_text= this.translateEntity(tooltip_text);
                  /*
                      This causes the crashy if it's up while updating.  :(

                    menuitem.setAttribute( "tooltiptext", tooltip_text );
                  */
                }

                menuitem.commandtype = obj_type;
                menuitem.commandmenu = menu;
                menuitem.commandindex = i;
                menuitem.commandobject = cmdobject;
              }
              else
              {
                menuitem = this.menuitems[i];
                menu = menuitem.commandmenu;
                obj_type = menuitem.commandtype;
                cmdobject = menuitem.commandobject;
              }

              if ( cmdobject.getCommandEnabled( menuitem.commandmenu, menuitem.commandindex, this.hoststring ) )
                menuitem.setAttribute( "disabled", "false" );
              else
                menuitem.setAttribute( "disabled", "true" );

              if (menuitem.commandtype == "flag") {
                menuitem.setAttribute("checked", cmdobject.getCommandFlag( menuitem.commandmenu, menuitem.commandindex, this.hoststring ));
              }
              if (menuitem.commandtype == "choiceitem") {
                menuitem.setAttribute("checked", (menuitem.id == cmdobject.getCommandChoiceItem( menuitem.commandmenu, this.hoststring )));
              }

              // Add it to the parent
              if (!stateonly)
              {
                this.menuitems.push( menuitem );
                if (obj_type == "submenu" || obj_type == "choice") {
                  var menupopup = document.createElement("menupopup");
                  menupopup.setAttribute("sbtype", "command");
                  menuitem.appendChild(menupopup);
                  if (!before) parentnode.appendChild(menuitem);
                  else parentnode.insertBefore( menuitem, before);
                  if (cmdobject.getCommandId(menu, i, this.hoststring) == null) {
                    Components.utils.reportError("null submenu: menu = " + menu + ", index = " + i);
                  }
                  this.refreshCommandItems(cmdobject, stateonly, cmdobject.getCommandId(menu, i, this.hoststring), menupopup, null, depth+1, (obj_type == "choice"));
                } else {
                  if (!before) parentnode.appendChild(menuitem);
                  else parentnode.insertBefore( menuitem, before);
                }
              }
            }
          } catch (e) {
            var id="";
            if (menuitem) {
              id = "- " + cmdobject.getCommandId(menu, menuitem.commandindex, this.hoststring) + " ";
            }
            Components.utils.reportError("sbCommands.xml - popup - refreshCommandItems " + id + e);
          }
        ]]>
      </body>
    </method>

    <method name="doRemoveCommands">
      <body>
        <![CDATA[
          try {
            // Delete the popup commands
            var popup = this.getParentPopup();
            if (popup) {
              var command_nodes = popup.getElementsByAttribute( 'sbtype', 'command' );
              while ( command_nodes.length > 0 )
              {
                var node = command_nodes.item( 0 );
                popup.removeChild(node);
              }
              this.menuitems.length = 0; // clear the array??
            }
          } catch (e) {
            Components.utils.reportError("sbCommands.xml - popup - " + e);
          }
        ]]>
      </body>
    </method>

    <method name="onMenuCommand">
      <parameter name="evt"/>
      <body>
        <![CDATA[
        try
        {
          if ( this.commands )
          {
            var cmdobject = evt.originalTarget.commandobject;
            if (!cmdobject) return;

#ifdef METRICS_ENABLED
            this.reportMetrics(evt.originalTarget.id);
#endif

            cmdobject.onCommand(evt.originalTarget.commandmenu,
                                evt.originalTarget.commandindex,
                                this.hoststring,
                                evt.originalTarget.id,
                                null);
            var type = evt.originalTarget.commandtype;
            if (type == "flag" || type == "choiceitem") this.refreshCommands(true);
          }
        }
        catch( err )
        {
          Components.utils.reportError( "sbCommands.xml - menu - onMenuCommand - " + err );
        }
      ]]>
      </body>
    </method>


    </implementation>

  </binding>




  <!-- COMMANDS SHORTCUTS -->




  <binding id="commands-shortcuts" extends="chrome://songbird/content/bindings/sbCommands.xml#commands-base">

    <content>
      <xul:sb-dynamic-keyset sbid="keyset"/>
    </content>

    <implementation type="application/x-javascript">

    <constructor>
    </constructor>

    <method name="destroy2">
      <body>
      <![CDATA[
        this.keyset.removeAllKeys();
        this.keyset.destroy();
      ]]>
      </body>
    </method>

    <field name="hoststring">"shortcuts"</field>
    <field name="keyset">document.getAnonymousElementByAttribute(this, "sbid", "keyset");</field>
    <field name="keys">new Array();</field>

    <method name="shouldForceRebuild">
      <body>
        // If our internal objects are out of sync, rebuild.
        return (this.keys.length == 0);
      </body>
    </method>

    <method name="doRefreshCommands">
      <parameter name="stateonly"/>
      <body>
        <![CDATA[
        try
        {
          if (!stateonly) {
            this.removeCommands();
          }

          if ( this.commands )
          {
            for (var i in this.commands) {
              this.refreshCommandItems(this.commands[i], stateonly, null, this, null, 0, false);
            }
          }
        }
        catch( err )
        {
          Components.utils.reportError( "sbCommands.xml - shortcuts - doRefreshCommands - " + err );
        }
        ]]>
      </body>
    </method>

    <method name="refreshCommandItems">
      <parameter name="cmdobject"/>
      <parameter name="stateonly"/>
      <parameter name="menu"/>
      <parameter name="parentnode"/>
      <parameter name="before"/>
      <parameter name="depth"/>
      <parameter name="radioitems"/>
      <body>
        <![CDATA[
          var key;
          try {
            // And make all the new stuff
            if (!cmdobject.getVisible(this.hoststring)) return;
            var num = cmdobject.getNumCommands(menu, this.hoststring);
            if (stateonly) num = this.keys.length;
            for ( var i = 0; i < num; i++ )
            {
              key = null;

              // skip ?
              if (!stateonly && !cmdobject.getCommandVisible( menu, i, this.hoststring )) continue;

              var subobject = cmdobject.getCommandSubObject( menu, i, this.hoststring );
              if (subobject) {
                this.refreshCommandItems(subobject, stateonly, menu, parentnode, before, depth, false);
                continue;
              }

              var obj_type;

              if (!stateonly)
              {
                // What type?
                if (radioitems) obj_type = "choiceitem";
                else obj_type = cmdobject.getCommandType( menu, i, this.hoststring );

                // What id?
                var obj_id = cmdobject.getCommandId( menu, i, this.hoststring );

                var makeKey;
                var skip;

                switch (obj_type) {
                  case "submenu":
                  case "choice":
                    makeKey = false;
                    skip = false;
                    break;
                  case "separator":
                  case "custom":
                  case "value":
                    makeKey = false;
                    skip = true;
                    break;
                  case "action":
                  case "choiceitem":
                  case "flag":
                  default:
                    makeKey = true;
                    skip = false;
                    break;
                }

                if (skip) continue;

                if (makeKey) {
                  // Add a key
                  var modifiers;
                  var keyname;

                  // No label unless you have a label
                  var modifiers = cmdobject.getCommandShortcutModifiers( menu, i, this.hoststring );
                  var keyname = cmdobject.getCommandShortcutKey( menu, i, this.hoststring );
                  var keycode = cmdobject.getCommandShortcutKeycode( menu, i, this.hoststring );
                  var local = cmdobject.getCommandShortcutLocal( menu, i, this.hoststring );
                  modifiers = this.translateEntity(modifiers);
                  keyname = this.translateEntity(keyname);
                  keycode = this.translateEntity(keycode);

                  if ((!keyname || keyname == "") &&
                      (!keycode || keycode == "")) continue;

                  var keytarget = this.parentNode;
                  if (this.playlist) keytarget = this.playlist.tree;
                  key = this.keyset.addKey( local, obj_id, modifiers, keyname, keycode, this, keytarget );

                  key.commandtype = obj_type;
                  key.commandmenu = menu;
                  key.commandindex = i;
                  key.commandobject = cmdobject;
                } else {
                  key = null;
                }
              }
              else
              {
                key = this.keys[i];
                obj_type = key.commandtype;
                cmdobject = key.commandobject;
              }

              if (key) {
                if ( cmdobject.getCommandEnabled( key.commandmenu, key.commandindex, this.hoststring ) ) {
                  key.setAttribute( "disabled", "false" );
                } else {
                  key.setAttribute( "disabled", "true" );
                }
              }

              if (!stateonly)
              {
                if (key) {
                  this.keys.push( key );
                }
                if (obj_type == "submenu" || obj_type == "choice") {
                  if (cmdobject.getCommandId(menu, i, this.hoststring) == null) {
                    Components.utils.reportError("null submenu: menu = " + menu + ", index = " + i);
                  }
                  this.refreshCommandItems(cmdobject, stateonly, cmdobject.getCommandId(menu, i, this.hoststring), parentnode, null, depth+1, (obj_type == "choice"));
                }
              }
            }
          } catch (e) {
            var id="";
            if (key) {
              id = "- " + cmdobject.getCommandId(menu, key.commandindex, this.hoststring) + " ";
            }
            Components.utils.reportError("sbCommands.xml - shortcuts - refreshCommandItems " + id + e);
          }
        ]]>
      </body>
    </method>

    <method name="doRemoveCommands">
      <body>
        <![CDATA[
          this.keyset.removeAllKeys();
          this.keys = new Array();
        ]]>
      </body>
    </method>

    <method name="onCommand">
      <parameter name="evt"/>
      <body>
        <![CDATA[
        try
        {
          if ( this.commands )
          {
            var cmdobject = evt.originalTarget.commandobject;
            if (!cmdobject) return;

#ifdef METRICS_ENABLED
            this.reportMetrics(evt.originalTarget.id);
#endif

            cmdobject.onCommand(evt.originalTarget.commandmenu,
                                evt.originalTarget.commandindex,
                                this.hoststring,
                                evt.originalTarget.id,
                                null);
          }
        }
        catch( err )
        {
          Components.utils.reportError( "sbCommands.xml - shortcuts - onMenuCommand - " + err );
        }
      ]]>
      </body>
    </method>

    </implementation>

  </binding>


</bindings>


